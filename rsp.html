<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #computer {
            width : 142px;
            height : 200px;
        }
    </style>
</head>
<body>
    <div id = 'computer'></div>
    <div>
        <button id = 'scissors' class = 'btn'>가위</button>
        <button id = 'rock' class = 'btn'>바위</button>
        <button id = 'paper' class = 'btn'>보</button>
    </div>
    <div id = 'score'>0</div>
    <script>
        //가위바위보 게임
        const $computer = document.querySelector('#computer');
        const $scissors = document.querySelector('#scissors');
        const $rock = document.querySelector('#rock');
        const $paper = document.querySelector('#paper');
        const $score = document.querySelector('#score');
        const IMG_URL = './rsp.png';
        //rsp.png -> 가위, 바위, 보가 합쳐진 하나의 이미지
        //서버에 이미지를 요청하는 횟수를 줄이기 위함이며 이미지 스프라이트(image sprite)라고 함
        //이미지가 하나로 합쳐져 있으므로 CSS와 자바스크립트로 적절히 잘라서 화면에 표시해야 함
        $computer.style.background = `url(${IMG_URL}) 0 0`;
        //`url(${IMG_URL}) 0 0` -> url(주소), x좌표, y좌표 (가위)
        /*
        $computer.style.background = `url(${IMG_URL}) -220px 0`;//(바위)
        $computer.style.background = `url(${IMG_URL}) -440px 0`;//(보)
        */

        //가위 바위 보 객체로 묶기
        //y좌표는 모두 0이므로 x좌표만 사용하면 됨
        const rspX = {
            scissors: '0',
            rock: '-220px',
            paper: '-440px',
        };
        $computer.style.backgroundSize = 'auto 200px'; // 가로(auto), 세로(200px), 가로세로 비율을 유지하면서 세로 길이가 200px이 될 때까지 이미지를 줄임

        //가위,바위,보 그림바꾸기
        let first = 'scissors'; //처음 내는 것(가위)
        const changeHand = () => {
            if (first === 'rock'){
                first = 'scissors';
            }
            else if(first === 'scissors'){
                first = 'paper';
            }
            else if(first === 'paper'){
                first = 'rock';
            }
            $computer.style.background = `url(${IMG_URL}) ${rspX[first]} 0`;
            $computer.style.backgroundSize = 'auto 200px';
        }
        //특정 주기마다 함수 실행(setInterval)
        //setInterval(changeHand, 50);

        //승부 확인을 위한 가위바위보 잠시 멈추기
        //let 아이디 = setInterval(함수, 밀리초);
        //clearInterval(아이디);
        //setTimeout함수의 취소도 똑같이 적용 가능
        /*
        let intervalid = setInterval(changeHand, 50);
        const clickButton = () => {
            clearInterval(intervalid);
            setTimeout(() => {
                intervalid = setInterval(changeHand, 50);
            }, 1000);
        };
            $scissors.addEventListener('click', clickButton);
            $paper.addEventListener('click', clickButton);
            $rock.addEventListener('click', clickButton);
        //버튼을 클릭할 때 마다 setTimeout 실행 -> 버튼을 누른 횟수만큼 setTimeout 타이머가 실행되고 1초 뒤에 setInterval을 하게되어 
        //버튼을 누를 떄 마다 그림이 바뀌는 속도가 빨라짐
        //이때문에 그림이 멈춰 있는 동안 버튼을 클릭해도 clickButton함수가 호출되지 않게 만들어야 함
        */

        /*//1. removeEventListener 메서드 사용
        //이벤트를 등록할 때와 제거할 떄의 함수가 같은 함수여야 함
        const clickButton = () => {
            clearInterval(intervalid);
            $scissors.removeEventListener('click', clickButton);
            $paper.removeEventListener('click', clickButton);
            $rock.removeEventListener('click', clickButton);

            setTimeout(() => {
            $scissors.addEventListener('click', clickButton);
            $paper.addEventListener('click', clickButton);
            $rock.addEventListener('click', clickButton);
            intervalid = setInterval(changeHand, 50);
        } , 1000)
        };
        $scissors.addEventListener('click', clickButton);
        $paper.addEventListener('click', clickButton);
        $rock.addEventListener('click', clickButton);
        */

        //2. 함수가 아무 일도 하지 않게 만들기
        let intervalid = setInterval(changeHand, 50);
        let clickable = true; //clickable변수를 만들고
        const clickButton = () => {
            if(clickable){
            clearInterval(intervalid);
            clickable = false; //클릭하는 동안 false로 , if문이 false가 되므로 버튼을 클릭해도 함수가 실행되지 않음
            setTimeout(() => {
            clickable = true; //타이머가 재개될 때 다시 true로 만들어 if문이 실행되도록 변경
            intervalid = setInterval(changeHand, 50);
        } , 1000);
        }
        };
        $scissors.addEventListener('click', clickButton);
        $paper.addEventListener('click', clickButton);
        $rock.addEventListener('click', clickButton);
    </script>
</body>
</html>